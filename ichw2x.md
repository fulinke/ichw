# ichw
1.
**Why Haulting Problem?**
  
  为了证明不存在一个神仙般的算法能够预测任意的一个算法和输入是否能停机，表明了机算机的局限。
**How to prove Haulting Problem?**

 其证明方法是反证法，数学原理用到了函数的对应关系和矛盾的逻辑关系
2.**科普ing**
  在大家已知的二进制中，有符号整数的表示大家已经知道有原码、反码，它们都能有效地表示数据的大小和正负。但是，在运算过程中，补码和反码都面临着困难，那就是不方便加减和有两个“0”的问题。举个例子，用反码计算时，必须将仅为加到结果里才能得到正确结果。举个例子吧 -2+3=？ 我们用反码来试试。-2的反码是1101，3的反码是0011，将两者相加
   1101  而四个bit内只能表示0，显然是与事实矛盾的。
  +0011
  ——————
  10000
  而我接下来介绍的补码，就巧妙地解决了上述两个问题。
  - 所谓补码，其实就是利用了在有限位数中数值有上限的思想，就好像钟表上一共是12个钟头，向后一个钟头和向前十一个钟头是等效的。所以对于正数的补码，只要和原码相同。对于负数的补码，只需要用2^N - |X|(N为码长，X为负整数）即可得到补码。
  - 补码在运算上可以简便地记忆为负数的反码加1。
  接下来我们继续从例子中来验证。-2+3=？-2的补码是1110，3的补码是0011，有：
   1110
  +0011
  ——————
  10001   其中最前一位的1溢出了，剩下的就是0001，表示正一，与事实相符。
  - 补码的另一个优势就是它只有一个0（0000）
  由于补码的上述两个优势，它是现在应用最广泛的整数表示法。
 3.依题意第一位表示符号，2到8位表示指数，9到16位表示小数位。
  
  |Sign|Exp|frac|Value|
  |-----|-----|-----|-----|
  |*|000 0000|0000 0000|±0|
  |*|011 1111|0000 0000|±1.0|
  |*|000 0000|1111 1111|±(1-2^-8) $/times$ 2^-62|
  |*|000 0000|0000 0001|±2^-8 $\times$ 2^-62|
  |*|000 0001|0000 0000|±2^-62|
  |*|111 1110|1111 1111|±(2-2^-8) $\times$ 2^63|
  |*|111 1111|0000 0000|± $\infty$|
  |*|111 1111|non zero|NaN|
